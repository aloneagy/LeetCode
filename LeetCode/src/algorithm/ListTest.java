//package algorithm;
//
///**
// * @author ynz
// * create at 2020-04-28 15:19
// * @description:this is the class for
// **/
//
//public class ListTest {
//    //删除最后一个节点
//    public ListNode DeleteLast(ListNode first){
//        ListNode cur=first;
//    }
//    //查看是否链表中值为k的节点
//    public boolean find(ListNode list,int k){
//
//    }
//    //将两个链表节点最为参数，第二个节点插入链表并使之称为第一个链表的后续节点
//    public ListNode insertAfter(ListNode first,ListNode second){
//
//    }
//    //删除后续节点（如果为空什么都不做）
//    public ListNode removeAfter(ListNode list){
//
//    }
//    //返回节点最大值,链表为空返回0
//    public int max(ListNode list){
//
//    }
//    //递归做上面的题
//    public int max2(ListNode listNode){
//
//    }
//    //用环形链表实现Queue，环形链表没有任何节点连接为空，只要链表非空则last.next的值为first,只能用一个Node的实例变量（list）
//
//    //反转链表
//public ListNode reverseList(ListNode head) {
//        ListNode cur = head, pre = null, next = null;
//        while(cur != null){
//        next = cur.next;
//        cur.next = pre;
//        pre = cur;
//        cur = next;
//        }
//        return pre;
//        }
//
//    //为Stack添加一个peek（）方法，返回栈中最近添加的元素
//
//    //编写一个QUEUE接受参数k并输出倒数第k个元素
//
//    //QUEUE删除第k个元素
//
//    //复制队列
//
//    //复制栈
//
//    //两个栈实现一个队列
//
//    //一个队列实现栈
//
//    //两个栈实现steque
//
//}
